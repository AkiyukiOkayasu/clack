//! Traits and associated utilities to handle and implement CLAP extensions.
//!
//! See the documentation of the `extensions` module in `clack-plugin` and `clack-host` for
//! implementation examples.

use core::ffi::c_void;
use std::ptr::NonNull;

/// A marker struct that represents extensions implemented by the plugin side.
pub struct PluginExtension;

/// A marker struct that represents extensions implemented by the host side.
pub struct HostExtension;

/// An extension type marker: either [`PluginExtension`] or [`HostExtension`]
pub trait ExtensionType: private::Sealed {}
impl ExtensionType for PluginExtension {}
impl ExtensionType for HostExtension {}

mod private {
    use super::*;

    pub trait Sealed {}
    impl Sealed for PluginExtension {}
    impl Sealed for HostExtension {}
}

/// # Safety
/// The IDENTIFIER must match the official identifier for the given extension, otherwise
/// the extension data could be misinterpreted, and UB could occur
pub unsafe trait Extension: Sized + 'static {
    /// The standard identifier for this extension.
    ///
    /// This MUST point to a C-style, null-terminated string.
    const IDENTIFIER: *const u8;
    /// Whether this is a host extension or a plugin extension
    type ExtensionType: ExtensionType;

    /// Returns an instance of the extension from a given extension pointer.
    ///
    /// # Safety
    /// The extension pointer must be valid for the duration of `'a`
    #[inline]
    unsafe fn from_extension_ptr<'a>(ptr: NonNull<c_void>) -> &'a Self {
        ptr.cast().as_ref()
    }
}

/// # Safety
/// The IDENTIFIER must match the official identifier for the given extension, otherwise
/// the extension data could be misinterpreted, and UB could occur
pub unsafe trait ExtensionImplementation<I>: Extension {
    /// The type of the interface that gets generated by this implementation.
    ///
    /// This is usually the C FFI-compatible struct that then gets sent between the plugin and host,
    /// for instance `clack_host_log` for the host side of the Log extension.
    type Interface: 'static;

    /// The interface instance for this implementation.
    const INTERFACE: &'static Self::Interface;

    #[inline]
    fn from_implementation() -> &'static Self {
        let ptr = NonNull::from(Self::INTERFACE).cast();
        unsafe { Self::from_extension_ptr(ptr) }
    }
}
